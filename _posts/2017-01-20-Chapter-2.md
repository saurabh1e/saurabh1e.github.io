---
layout: post
title:  "Chapter 2: Flask: Diving Deeper in SQLAlchemy"
date:   2017-01-20
desc: "Python"
keywords: "Python, Flask, SqlAlchemy"
categories: [Python]
tags: [Python, Flask, SqlAlchemy]
icon: icon-python
---


## Chapter 2: Diving Deep with SQLAlchemy


In the last chapter we learnt the basics of using SqlAlchemy with flask in this chapter we will dive deeper with relationships, see what are good and bad way of writing queries and we will learn about things to keep in mind while building a databases.

###  Creating Database.

We will be creating a database for blog website. We will use the user model from our last chapter optimize it and creating new tables for Post, Comments, Rating etc.

 **Current User Model.**

``` python
class User(db.Model, BaseMixin, ReprMixin):

	email = db.Column(db.String(120), unique=True, nullable=False)
	password = db.Column(db.String(255))
	first_name = db.Column(db.String(40), nullable=False)
	last_name = db.Column(db.String(40))
	profile_picture = db.Column(db.Text()))
	bio = db.Column(db.Text()))
	active = db.Column(db.Boolean(), default=False)
	last_login_at = db.Column(db.DateTime())
	date_of_birth = db.Column(db.Date)
	mobile_number = db.Column(db.String(10), unique=True)
	gender = db.Column(db.Enum('male', 'female', 'other', name='varchar'))
	marital_status = db.Column(db.Enum('single', 'married', 'divorced',
									   'widowed', name='varchar'))
	education = db.Column(db.Enum('undergraduate', 'graduate', 'post_graduate', 
						  name='varchar'))
	
	roles = db.relationship('Role', back_populates='users', secondary='user_role')

	@hybrid_property
	def name(self):
		return '{}'.format(self.first_name) + 
			   (' {}'.format(self.last_name) if self.last_name else '')

```

We can have now around 16 columns in our user table which is perfectly fine, but if we have a table with lots of columns that are frequently accessed and lots of column which are used less frequently then it's a good approach to divide it into 2 tables.

**Like:**

``` python

class User(db.Model, BaseMixin, ReprMixin):

	email = db.Column(db.String(120), unique=True, nullable=False)
	password = db.Column(db.String(255))
	active = db.Column(db.Boolean(), default=False)
	last_login_at = db.Column(db.DateTime())
	mobile_number = db.Column(db.String(10), unique=True)
	
	roles = db.relationship('Role', back_populates='users', secondary='user_role')
	user_profile = db.relationship("UserProfile", back_populates="user", 
									uselist=True, cascade='all, delete-orphan', 
									lazy='select')
	                               
	@hybrid_property
	def name(self):
		return '{}'.format(self.first_name) + (' {}'.format(self.last_name) if 
			   self.last_name else '')


class UserProfile(db.Model, BaseMixin, ReprMixin):
	__repr__ = ['id', 'first_name']

	first_name = db.Column(db.String(40), nullable=False)
		last_name = db.Column(db.String(40))
		profile_picture = db.Column(db.Text())
		bio = db.Column(db.Text())
		date_of_birth = db.Column(db.Date)
		gender = db.Column(db.Enum('male', 'female', 'other', name='varchar'))
		marital_status = db.Column(db.Enum('single', 'married', 'divorced',
										   'widowed',  name='varchar'))
		education = db.Column(db.Enum('undergraduate', 'graduate', 'post_graduate', 
									  name='varchar'))
	
	user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), 
						unique=True)
	
	user = db.relationship('User', back_populates="user_profile",
						   single_parent=True)
```

We have created one more table user_profile which contains less frequently accessed columns. The linking between **user** and **user** **profile** is created by adding a foreign key **user_id** in user_profile table with a **unique** **constrain** which makes it a one to one connection as no two user profile can contain same user_id. 

A property named **user** is added in **UserProfile** and **user_profile** in **User**. Lets see all the options configured in these two tables.

``` python
user_profile = db.relationship("UserProfile", back_populates="user", 
								userlist=False, cascade='all,
								delete-orphan', lazy='select')
```

1. `***'UserProfile'*:** The name of the Class with which a relationship has to be established.

2.  **back_populates="*user*":** This is the complementing property to ***user*** property in ***UserProfile*** model.

3.  **cascade:** This refers to how operations performed on a “parent” object should be propagated to items referred to by that relationship [more here](http://docs.sqlalchemy.org/en/latest/orm/cascades.html#unitofwork-cascades).
In this case delete-orphan indicates that the user_profile object should follow along with its parent (***User Model***) in all cases, and be deleted once it is no longer associated with that parent.

4. **uselist=*False*:**  This means that only one object of the related model will be returned.

5.  **lazy=*'select'*:** This defines the relation loading technique, for instance *'select'* here means that when ever a user object is created like: `user = User.query.first()`,  user_profile of that object will not be loaded from the database until user_profile property of the user is accessed like `user.user_profile`.  A select query is emitted when the property is accessed. Using `subquery` instead of `select` will result in fetching of the user profile within the same query, and `user.user_profile` will contain the user profile object irrespective if it is accessed or not.


**Post, Comment and Rating Model**

``` python

class Post(db.Model, BaseMixin, ReprMixin):
    __repr_fields__ = ['id', 'slug']

    slug = db.Column(db.String(55), unique=True, nullable=False)
    title = db.Column(db.String(255), unique=True, nullable=False)
    data = db.Column(db.Text, nullable=False)
    likes = db.Column(db.Integer, default=0)
    dis_likes = db.Column(db.Integer, default=0)
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    author = db.relationship('User', single_parent=True, foreign_keys=[author_id])
    ratings = db.relationship('UserRating', back_populates='post', uselist=True,
                              lazy='dynamic')
    comments = db.relationship('Comment', back_populates='post', uselist=True,
                               lazy='dynamic')

    @hybrid_property
    def avg_rating(self):
        return self.ratings.with_entities(func.Avg(UserRating.rating)).filter(UserRating.post_id == self.id).scalar()

    @hybrid_property
    def total_comments(self):
        return self.comments.with_entities(func.Count(Comment.id)).filter(Comment.post_id == self.id).scalar()


class Comment(db.Model, BaseMixin, ReprMixin):
    __repr_fields__ = ['id', 'commented_by']

    data = db.Column(db.Text, nullable=False)
    is_moderated = db.Column(db.Boolean(), default=False)

    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))
    commented_by = db.Column(db.Integer, db.ForeignKey('user.id'))

    post = db.relationship('Post', foreign_keys=[post_id], back_populates='comments')
    commenter = db.relationship('User', foreign_keys=[commented_by], back_populates='comments')


class UserRating(db.Model, BaseMixin, ReprMixin):
    __repr_fields__ = ['rating', 'post_id', 'rated_by']

    rating = db.Column(db.SmallInteger, nullable=False)

    rated_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    post_id = db.Column(db.Integer, db.ForeignKey('post.id'))

    post = db.relationship('Post', back_populates='ratings', foreign_keys=[post_id])
    rater = db.relationship('User', foreign_keys=[rated_by], back_populates='ratings')

```
